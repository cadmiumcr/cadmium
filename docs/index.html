<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Crystal Docs 0.27.2">


<link href="css/style.css" rel="stylesheet" type="text/css">

<script type="text/javascript" src="js/doc.js"></script>
<script type="text/javascript">
  CrystalDoc.base_path = "";
</script>

  <meta id="repository-name" content="github.com/watzon/cadmium">
  <title>README - github.com/watzon/cadmium</title>
</head>
<body>

<div class="sidebar">
  <div class="sidebar-header">
    <div class="search-box">
      <input type="search" class="search-input" placeholder="Search..." spellcheck="false" aria-label="Search">
    </div>

    <div class="repository-links">
      <a href="index.html">README</a>
    </div>
  </div>

  <div class="search-results" class="hidden">
    <ul class="search-list"></ul>
  </div>

  <div class="types-list">
    <ul>
  
  <li class="parent " data-id="github.com/watzon/cadmium/Cadmium" data-name="cadmium">
      <a href="Cadmium.html">Cadmium</a>
      
        <ul>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/AggressiveTokenizer" data-name="cadmium::aggressivetokenizer">
      <a href="Cadmium/AggressiveTokenizer.html">AggressiveTokenizer</a>
      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/BayesClassifier" data-name="cadmium::bayesclassifier">
      <a href="Cadmium/BayesClassifier.html">BayesClassifier</a>
      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/CaseTokenizer" data-name="cadmium::casetokenizer">
      <a href="Cadmium/CaseTokenizer.html">CaseTokenizer</a>
      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/Classifiers" data-name="cadmium::classifiers">
      <a href="Cadmium/Classifiers.html">Classifiers</a>
      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/CountInflector" data-name="cadmium::countinflector">
      <a href="Cadmium/CountInflector.html">CountInflector</a>
      
    </li>
  
  <li class="parent " data-id="github.com/watzon/cadmium/Cadmium/EdgeWeightedDigraph" data-name="cadmium::edgeweighteddigraph">
      <a href="Cadmium/EdgeWeightedDigraph.html">EdgeWeightedDigraph</a>
      
        <ul>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/EdgeWeightedDigraph/Bag" data-name="cadmium::edgeweighteddigraph::bag(t)">
      <a href="Cadmium/EdgeWeightedDigraph/Bag.html">Bag</a>
      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/EdgeWeightedDigraph/DirectedEdge" data-name="cadmium::edgeweighteddigraph::directededge">
      <a href="Cadmium/EdgeWeightedDigraph/DirectedEdge.html">DirectedEdge</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class="parent " data-id="github.com/watzon/cadmium/Cadmium/Graph" data-name="cadmium::graph">
      <a href="Cadmium/Graph.html">Graph</a>
      
        <ul>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/Graph/ShortestPath" data-name="cadmium::graph::shortestpath">
      <a href="Cadmium/Graph/ShortestPath.html">ShortestPath</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/IntExtension" data-name="cadmium::intextension">
      <a href="Cadmium/IntExtension.html">IntExtension</a>
      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/JaroWinklerDistance" data-name="cadmium::jarowinklerdistance">
      <a href="Cadmium/JaroWinklerDistance.html">JaroWinklerDistance</a>
      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/LevenshteinDistance" data-name="cadmium::levenshteindistance">
      <a href="Cadmium/LevenshteinDistance.html">LevenshteinDistance</a>
      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/LogisticRegression" data-name="cadmium::logisticregression">
      <a href="Cadmium/LogisticRegression.html">LogisticRegression</a>
      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/Metaphone" data-name="cadmium::metaphone">
      <a href="Cadmium/Metaphone.html">Metaphone</a>
      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/NGrams" data-name="cadmium::ngrams">
      <a href="Cadmium/NGrams.html">NGrams</a>
      
    </li>
  
  <li class="parent " data-id="github.com/watzon/cadmium/Cadmium/Normalizers" data-name="cadmium::normalizers">
      <a href="Cadmium/Normalizers.html">Normalizers</a>
      
        <ul>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/Normalizers/RemoveDiacritics" data-name="cadmium::normalizers::removediacritics">
      <a href="Cadmium/Normalizers/RemoveDiacritics.html">RemoveDiacritics</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/NounInflector" data-name="cadmium::nouninflector">
      <a href="Cadmium/NounInflector.html">NounInflector</a>
      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/PairDistance" data-name="cadmium::pairdistance">
      <a href="Cadmium/PairDistance.html">PairDistance</a>
      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/Phonetics" data-name="cadmium::phonetics">
      <a href="Cadmium/Phonetics.html">Phonetics</a>
      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/PorterStemmer" data-name="cadmium::porterstemmer">
      <a href="Cadmium/PorterStemmer.html">PorterStemmer</a>
      
    </li>
  
  <li class="parent " data-id="github.com/watzon/cadmium/Cadmium/PragmaticTokenizer" data-name="cadmium::pragmatictokenizer">
      <a href="Cadmium/PragmaticTokenizer.html">PragmaticTokenizer</a>
      
        <ul>
  
  <li class="parent " data-id="github.com/watzon/cadmium/Cadmium/PragmaticTokenizer/Languages" data-name="cadmium::pragmatictokenizer::languages">
      <a href="Cadmium/PragmaticTokenizer/Languages.html">Languages</a>
      
        <ul>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/PragmaticTokenizer/Languages/Common" data-name="cadmium::pragmatictokenizer::languages::common">
      <a href="Cadmium/PragmaticTokenizer/Languages/Common.html">Common</a>
      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/PragmaticTokenizer/Languages/Deutsch" data-name="cadmium::pragmatictokenizer::languages::deutsch">
      <a href="Cadmium/PragmaticTokenizer/Languages/Deutsch.html">Deutsch</a>
      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/PragmaticTokenizer/Languages/English" data-name="cadmium::pragmatictokenizer::languages::english">
      <a href="Cadmium/PragmaticTokenizer/Languages/English.html">English</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/PragmaticTokenizer/MentionsOptions" data-name="cadmium::pragmatictokenizer::mentionsoptions">
      <a href="Cadmium/PragmaticTokenizer/MentionsOptions.html">MentionsOptions</a>
      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/PragmaticTokenizer/NumbersOptions" data-name="cadmium::pragmatictokenizer::numbersoptions">
      <a href="Cadmium/PragmaticTokenizer/NumbersOptions.html">NumbersOptions</a>
      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/PragmaticTokenizer/PunctuationOptions" data-name="cadmium::pragmatictokenizer::punctuationoptions">
      <a href="Cadmium/PragmaticTokenizer/PunctuationOptions.html">PunctuationOptions</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/PresentVerbInflector" data-name="cadmium::presentverbinflector">
      <a href="Cadmium/PresentVerbInflector.html">PresentVerbInflector</a>
      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/Readability" data-name="cadmium::readability">
      <a href="Cadmium/Readability.html">Readability</a>
      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/RegexTokenizer" data-name="cadmium::regextokenizer">
      <a href="Cadmium/RegexTokenizer.html">RegexTokenizer</a>
      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/SentenceTokenizer" data-name="cadmium::sentencetokenizer">
      <a href="Cadmium/SentenceTokenizer.html">SentenceTokenizer</a>
      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/Sentiment" data-name="cadmium::sentiment">
      <a href="Cadmium/Sentiment.html">Sentiment</a>
      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/SoundEx" data-name="cadmium::soundex">
      <a href="Cadmium/SoundEx.html">SoundEx</a>
      
    </li>
  
  <li class="parent " data-id="github.com/watzon/cadmium/Cadmium/Stemmer" data-name="cadmium::stemmer">
      <a href="Cadmium/Stemmer.html">Stemmer</a>
      
        <ul>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/Stemmer/Token" data-name="cadmium::stemmer::token">
      <a href="Cadmium/Stemmer/Token.html">Token</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/StringExtension" data-name="cadmium::stringextension">
      <a href="Cadmium/StringExtension.html">StringExtension</a>
      
    </li>
  
  <li class="parent " data-id="github.com/watzon/cadmium/Cadmium/TenseInflector" data-name="cadmium::tenseinflector">
      <a href="Cadmium/TenseInflector.html">TenseInflector</a>
      
        <ul>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/TenseInflector/FormSet" data-name="cadmium::tenseinflector::formset">
      <a href="Cadmium/TenseInflector/FormSet.html">FormSet</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class="parent " data-id="github.com/watzon/cadmium/Cadmium/TfIdf" data-name="cadmium::tfidf">
      <a href="Cadmium/TfIdf.html">TfIdf</a>
      
        <ul>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/TfIdf/Document" data-name="cadmium::tfidf::document">
      <a href="Cadmium/TfIdf/Document.html">Document</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/Tokenizer" data-name="cadmium::tokenizer">
      <a href="Cadmium/Tokenizer.html">Tokenizer</a>
      
    </li>
  
  <li class="parent " data-id="github.com/watzon/cadmium/Cadmium/Transliterator" data-name="cadmium::transliterator">
      <a href="Cadmium/Transliterator.html">Transliterator</a>
      
        <ul>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/Transliterator/StringExtension" data-name="cadmium::transliterator::stringextension">
      <a href="Cadmium/Transliterator/StringExtension.html">StringExtension</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/TreebankWordTokenizer" data-name="cadmium::treebankwordtokenizer">
      <a href="Cadmium/TreebankWordTokenizer.html">TreebankWordTokenizer</a>
      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/Trie" data-name="cadmium::trie">
      <a href="Cadmium/Trie.html">Trie</a>
      
    </li>
  
  <li class="parent " data-id="github.com/watzon/cadmium/Cadmium/Util" data-name="cadmium::util">
      <a href="Cadmium/Util.html">Util</a>
      
        <ul>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/Util/Paragraph" data-name="cadmium::util::paragraph">
      <a href="Cadmium/Util/Paragraph.html">Paragraph</a>
      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/Util/Sentence" data-name="cadmium::util::sentence">
      <a href="Cadmium/Util/Sentence.html">Sentence</a>
      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/Util/StopWords" data-name="cadmium::util::stopwords">
      <a href="Cadmium/Util/StopWords.html">StopWords</a>
      
    </li>
  
  <li class="parent " data-id="github.com/watzon/cadmium/Cadmium/Util/Syllable" data-name="cadmium::util::syllable">
      <a href="Cadmium/Util/Syllable.html">Syllable</a>
      
        <ul>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/Util/Syllable/Guess" data-name="cadmium::util::syllable::guess">
      <a href="Cadmium/Util/Syllable/Guess.html">Guess</a>
      
    </li>
  
</ul>

      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/VisibleCharTokenizer" data-name="cadmium::visiblechartokenizer">
      <a href="Cadmium/VisibleCharTokenizer.html">VisibleCharTokenizer</a>
      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/WhitespaceTokenizer" data-name="cadmium::whitespacetokenizer">
      <a href="Cadmium/WhitespaceTokenizer.html">WhitespaceTokenizer</a>
      
    </li>
  
  <li class="parent " data-id="github.com/watzon/cadmium/Cadmium/WordNet" data-name="cadmium::wordnet">
      <a href="Cadmium/WordNet.html">WordNet</a>
      
        <ul>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/WordNet/DB" data-name="cadmium::wordnet::db">
      <a href="Cadmium/WordNet/DB.html">DB</a>
      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/WordNet/Lemma" data-name="cadmium::wordnet::lemma">
      <a href="Cadmium/WordNet/Lemma.html">Lemma</a>
      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/WordNet/Pointer" data-name="cadmium::wordnet::pointer">
      <a href="Cadmium/WordNet/Pointer.html">Pointer</a>
      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/WordNet/Synset" data-name="cadmium::wordnet::synset">
      <a href="Cadmium/WordNet/Synset.html">Synset</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/WordPunctuationTokenizer" data-name="cadmium::wordpunctuationtokenizer">
      <a href="Cadmium/WordPunctuationTokenizer.html">WordPunctuationTokenizer</a>
      
    </li>
  
  <li class=" " data-id="github.com/watzon/cadmium/Cadmium/WordTokenizer" data-name="cadmium::wordtokenizer">
      <a href="Cadmium/WordTokenizer.html">WordTokenizer</a>
      
    </li>
  
</ul>

      
    </li>
  
</ul>

  </div>
</div>


<div class="main-content">
<p><img src="img/cadmium.png" alt="Logo"/></p>

<p><a href="https://travis-ci.org/watzon/cadmium" target="_blank"><img src="https://img.shields.io/travis/watzon/cadmium.svg" alt="Travis"/></a> <img src="https://img.shields.io/github/license/watzon/cadmium.svg" alt="license"/></p>

<p>Cadmium is a Natural Language Processing (NLP) library for Crystal. Included are classes and modules for tokenizing, inflecting, stemming, and creating n-grams with much more to come.</p>

<p>It's still in early development, but tests are being written as I go so hopefully it will be somewhat stable.</p>

<p>This library is heavily based on the <a href="https://github.com/NaturalNode/natural" target="_blank">natural</a> library for node.js, and as such you can expect the API's to be very similar. As a point of fact, most of the specs for Cadmium were copied directly from natural and lightly modified.</p>

<p>Any utilities that can be internationalized will be eventually. For now English is the primary concern.</p>

<p>For full API documentation check out <a href="https://watzon.github.io/cadmium/" target="_blank">the docs</a>.</p>

<h2>Table of Contents</h2>

<ul><li><a href="#installation" target="_blank">Installation</a></li><li><a href="#tokenizers" target="_blank">Tokenizers</a></li><li><a href="#string-distance" target="_blank">String Distance</a></li><li><a href="#stemmers" target="_blank">Stemmers</a></li><li><a href="#phonetics" target="_blank">Phonetics</a></li><li><a href="#inflectors" target="_blank">Inflectors</a></li><li><a href="#n-grams" target="_blank">N-Grams</a></li><li><a href="#classifiers" target="_blank">Classifiers</a></li><li><a href="#tf-idf" target="_blank">tf-idf</a></li><li><a href="#transliterator" target="_blank">Transliterator</a></li><li><a href="#sentiment-analysis" target="_blank">Sentiment Analysis</a></li><li><a href="#tries" target="_blank">Tries</a></li><li><a href="#edge-weighted-digraph" target="_blank">EdgeWeightedDigraph</a></li><li><a href="#readability" target="_blank">Readability</a></li><li><a href="#wordnet" target="_blank">WordNet</a></li><li><a href="#roadmap" target="_blank">Roadmap</a></li><li><a href="#contributing" target="_blank">Contributing</a></li><li><a href="#contributors" target="_blank">Contributors</a></li></ul>

<h2>Installation</h2>

<p>Add this to your application's <code>shard.yml</code>:</p>

<pre><code class="language-yaml">dependencies:
  cadmium:
    github: watzon/cadmium
    branch: master</code></pre>

<h2>Usage</h2>

<p>Require the cadmium library in your project</p>

<pre><code class="language-crystal"><span class="k">require</span> <span class="s">&quot;cadmium&quot;</span></code></pre>

<h3>Tokenizers</h3>

<p>Cadmium includes several different tokenizers, each of which is useful for different applications.</p>

<h4>Aggressive Tokenizer</h4>

<p>The aggressive tokenizer currently has localization available for English (:en / nil), Spanish (:es), Persian (:fa), French (:fr), Indonesian (:id), Dutch (:nl), Norwegian (:no), Polish (:pl), Portuguese (:pt), Russian (:ru), and Swedish (:sv). If no language is included it will default to English.</p>

<p>Use it like so:</p>

<pre><code class="language-crystal">tokenizer <span class="o">=</span> <span class="t">Cadmium</span>.aggressive_tokenizer.<span class="k">new</span>(lang: <span class="n">:es</span>)
tokenizer.tokenize(<span class="s">&quot;hola yo me llamo eduardo y esudi√© ingenier√≠a&quot;</span>)
<span class="c"># =&gt; [&quot;hola&quot;, &quot;yo&quot;, &quot;me&quot;, &quot;llamo&quot;, &quot;eduardo&quot;, &quot;y&quot;, &quot;esudi√©&quot;, &quot;ingenier√≠a&quot;]</span></code></pre>

<h4>Case Tokenizer</h4>

<p>The case tokenizer doesn't rely on Regex and as such should be pretty fast. It should also work on an international basis fairly easily.</p>

<pre><code class="language-crystal">tokenizer <span class="o">=</span> <span class="t">Cadmium</span>.case_tokenizer.<span class="k">new</span>
tokenizer.tokenize(<span class="s">&quot;these are strings&quot;</span>)
<span class="c"># =&gt; [&quot;these&quot;, &quot;are&quot;, &quot;strings&quot;]</span>

tokenizer <span class="o">=</span> <span class="t">Cadmium</span>.case_tokenizer.<span class="k">new</span>(preserve_apostrophes: <span class="n">true</span>)
tokenizer.tokenize(<span class="s">&quot;Affectueusement surnomm√© ¬´ Gabo ¬ª dans toute l&#39;Am√©rique latine&quot;</span>)
<span class="c"># =&gt; [&quot;Affectueusement&quot;, &quot;surnomm√©&quot;, &quot;Gabo&quot;, &quot;dans&quot;, &quot;toute&quot;, &quot;l&quot;, &quot;Am√©rique&quot;, &quot;latine&quot;]</span></code></pre>

<h4>Regex Tokenizer</h4>

<p>The whitespace tokenizer, word punctuation tokenizer, and word tokenizer all extend the regex tokenizer. It uses Regex to match on the correct values.</p>

<pre><code class="language-crystal">tokenizer <span class="o">=</span> <span class="t">Cadmium</span>.word_punctuation_tokenizer.<span class="k">new</span>
tokenizer.tokenize(<span class="s">&quot;my dog hasn&#39;t any fleas.&quot;</span>)
<span class="c"># =&gt; [&quot;my&quot;, &quot;dog&quot;, &quot;hasn&quot;, &quot;&#39;&quot;, &quot;t&quot;, &quot;any&quot;, &quot;fleas&quot;, &quot;.&quot;]</span></code></pre>

<h4>Treebank Word Tokenizer</h4>

<p>The treebank tokenizer uses regular expressions to tokenize text as in Penn Treebank. This implementation is a port of the tokenizer sed script written by Robert McIntyre. To read about treebanks you can visit <a href="https://en.wikipedia.org/wiki/Treebank" target="_blank">wikipedia</a>.</p>

<pre><code class="language-crystal">tokenizer <span class="o">=</span> <span class="t">Cadmium</span>.treebank_word_tokenizer.<span class="k">new</span>
tokenizer.tokenize(<span class="s">&quot;If we &#39;all&#39; can&#39;t go. I&#39;ll stay home.&quot;</span>)
<span class="c"># =&gt; [&quot;If&quot;, &quot;we&quot;, &quot;&#39;all&quot;, &quot;&#39;&quot;, &quot;ca&quot;, &quot;n&#39;t&quot;, &quot;go.&quot;, &quot;I&quot;, &quot;&#39;ll&quot;, &quot;stay&quot;, &quot;home&quot;, &quot;.&quot;]</span></code></pre>

<h4>Pragmatic Tokenizer</h4>

<p>The pragmatic tokenizer is based off of the ruby gem from diasks2 which you can find <a href="https://github.com/diasks2/pragmatic_tokenizer" target="_blank">here</a>. It is a multilengual tokenizer which provides a wide array of options for tokenizing strings. For complete documentation check <a href="https://watzon.github.io/cadmium/Cadmium/Tokenizer/Pragmatic.html" target="_blank">here</a>.</p>

<p>Example is taken directly from the diasks2/pragmatic_tokenizer documentation, with a few modifications. Currently supported languages are:</p>

<ul><li>English (:en)</li><li>Deutsch (:de)</li></ul>

<pre><code class="language-crystal">text <span class="o">=</span> <span class="s">&quot;\&quot;I said, &#39;what&#39;re you? Crazy?&#39;\&quot; said Sandowsky. \&quot;I can&#39;t afford to do that.\&quot;&quot;</span>

<span class="t">Cadmium</span>.pragmatic_tokenizer.<span class="k">new</span>.tokenize(text)
<span class="c"># =&gt; [&quot;\&quot;&quot;, &quot;i&quot;, &quot;said&quot;, &quot;,&quot;, &quot;&#39;&quot;, &quot;what&#39;re&quot;, &quot;you&quot;, &quot;?&quot;, &quot;crazy&quot;, &quot;?&quot;, &quot;&#39;&quot;, &quot;\&quot;&quot;, &quot;said&quot;, &quot;sandowsky&quot;, &quot;.&quot;, &quot;\&quot;&quot;, &quot;i&quot;, &quot;can&#39;t&quot;, &quot;afford&quot;, &quot;to&quot;, &quot;do&quot;, &quot;that&quot;, &quot;.&quot;, &quot;\&quot;&quot;]</span>

<span class="c"># You can pass many different options to #initialize:</span>
options <span class="o">=</span> {
  language:            <span class="n">:en</span>, <span class="c"># the language of the string you are tokenizing</span>
  abbreviations:       <span class="t">Set</span>{<span class="s">&quot;a.b&quot;</span>, <span class="s">&quot;a&quot;</span>}, <span class="c"># a user-supplied array of abbreviations (downcased with ending period removed)</span>
  stop_words:          <span class="t">Set</span>{<span class="s">&quot;is&quot;</span>, <span class="s">&quot;the&quot;</span>}, <span class="c"># a user-supplied array of stop words (downcased)</span>
  remove_stop_words:   <span class="n">true</span>, <span class="c"># remove stop words</span>
  contractions:        { <span class="s">&quot;i&#39;m&quot;</span> => <span class="s">&quot;i am&quot;</span> }, <span class="c"># a user-supplied hash of contractions (key is the contracted form; value is the expanded form - both the key and value should be downcased)</span>
  expand_contractions: <span class="n">true</span>, <span class="c"># (i.e. [&quot;isn&#39;t&quot;] will change to two tokens [&quot;is&quot;, &quot;not&quot;])</span>
  filter_languages:    [<span class="n">:en</span>, <span class="n">:de</span>], <span class="c"># process abbreviations, contractions and stop words for this array of languages</span>
  punctuation:         <span class="n">:none</span>, <span class="c"># see below for more details</span>
  numbers:             <span class="n">:none</span>, <span class="c"># see below for more details</span>
  remove_emoji:        <span class="n">true</span>, <span class="c"># remove any emoji tokens</span>
  remove_urls:         <span class="n">true</span>, <span class="c"># remove any urls</span>
  remove_emails:       <span class="n">true</span>, <span class="c"># remove any emails</span>
  remove_domains:      <span class="n">true</span>, <span class="c"># remove any domains</span>
  hashtags:            <span class="n">:keep_and_clean</span>, <span class="c"># remove the hastag prefix</span>
  mentions:            <span class="n">:keep_and_clean</span>, <span class="c"># remove the @ prefix</span>
  clean:               <span class="n">true</span>, <span class="c"># remove some special characters</span>
  classic_filter:      <span class="n">true</span>, <span class="c"># removes dots from acronyms and &#39;s from the end of tokens</span>
  downcase:            <span class="n">false</span>, <span class="c"># do not downcase tokens</span>
  minimum_length:      <span class="n">3</span>, <span class="c"># remove any tokens less than 3 characters</span>
  long_word_split:     <span class="n">10</span> <span class="c"># split tokens longer than 10 characters at hypens or underscores</span>
}</code></pre>

<h3>String Distance</h3>

<p>Corundum provides an implimentation of two different string distance algorithms, the <a href="http://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance" target="_blank">Jaro-Winkler Distance Algorithm</a> and the <a href="https://en.wikipedia.org/wiki/Levenshtein_distance" target="_blank">Levenshtein Distance Algorithm</a>.</p>

<h4>Jaro-Winkler</h4>

<p>The Jaro-Winkler algorithm returns a number between 0 and 1 which tells how closely two strings match (1 being perfect and 0 being not at all).</p>

<pre><code class="language-crystal">jwd <span class="o">=</span> <span class="t">Cadmium</span>.jaro_winkler.<span class="k">new</span>

jwd.distance(<span class="s">&quot;dixon&quot;</span>,<span class="s">&quot;dicksonx&quot;</span>)
<span class="c"># =&gt; 0.8133333333333332</span>

jwd.distance(<span class="s">&quot;same&quot;</span>,<span class="s">&quot;same&quot;</span>)
<span class="c"># =&gt; 1</span>

jwd.distance(<span class="s">&quot;not&quot;</span>,<span class="s">&quot;same&quot;</span>)
<span class="c"># =&gt; 0.0</span></code></pre>

<h4>Levenshtein</h4>

<p>The Levenshtein distance algorithm returns the number of edits (insertions, modifications, or deletions) required to transform one string into another.</p>

<pre><code class="language-crystal"><span class="t">Cadmium</span>.levenshtein.distance(<span class="s">&quot;doctor&quot;</span>, <span class="s">&quot;doktor&quot;</span>)
<span class="c"># =&gt; 1</span>

<span class="t">Cadmium</span>.levenshtein.distance(<span class="s">&quot;doctor&quot;</span>, <span class="s">&quot;doctor&quot;</span>)
<span class="c"># =&gt; 0</span>

<span class="t">Cadmium</span>.levenshtein.distance(<span class="s">&quot;flad&quot;</span>, <span class="s">&quot;flaten&quot;</span>)
<span class="c"># =&gt; 3</span></code></pre>

<h4>Pair</h4>

<p>Pair Distance uses arbitrary n-grams to calculate how similar one string is to another. By calculating the bi-grams for a string, the pair distance algorithm first checks how many occurrences of each bi-gram occur in both strings, then it calculates their similarity with the formula <code>simularity = (2 ¬∑ intersections) / (s1size + s2size)</code>.</p>

<pre><code class="language-crystal"><span class="t">Cadmium</span>.pair_distance.distance(<span class="s">&quot;night&quot;</span>, <span class="s">&quot;nacht&quot;</span>)
<span class="c"># =&gt; 0.25</span></code></pre>

<h3>Stemmers</h3>

<p>Currently Cadmium only comes with a <a href="http://tartarus.org/martin/PorterStemmer/index.html" target="_blank">Porter</a> Stemmer, but <a href="http://www.comp.lancs.ac.uk/computing/research/stemming/" target="_blank">Lancaster</a> will be added soon. Stemmer methods <code>stem</code> and <code>tokenize_and_stem</code> have also been added to the String class to simplify use.</p>

<pre><code class="language-crystal"><span class="s">&quot;words&quot;</span>.stem
<span class="c"># =&gt; word</span>

<span class="s">&quot;i am waking up to the sounds of chainsaws&quot;</span>.tokenize_and_stem
<span class="c"># =&gt; [&quot;wake&quot;, &quot;sound&quot;, &quot;chainsaw&quot;]</span></code></pre>

<h3>Phonetics</h3>

<p>Phonetic matching (sounds-like) matching can be done with the SoundEx or Metaphone algorithms</p>

<pre><code class="language-crystal">sound_ex <span class="o">=</span> <span class="t">Cadmium</span>.sound_ex
metaphone <span class="o">=</span> <span class="t">Cadmium</span>.metaphone

sound_ex.process(<span class="s">&quot;phonetics&quot;</span>)
<span class="c"># =&gt; &quot;P532&quot;</span>

sound_ex.tokenize_and_phoneticize(<span class="s">&quot;Ruby aint got nothing on Crystal&quot;</span>)
<span class="c"># =&gt; [&quot;R100&quot;, &quot;A530&quot;, &quot;G300&quot;, &quot;C234&quot;]</span>

<span class="c"># Keep word stops</span>
sound_ex.tokenize_and_phoneticize(<span class="s">&quot;Ruby aint got nothing on Crystal&quot;</span>, <span class="n">true</span>)
<span class="c"># =&gt; [&quot;R100&quot;, &quot;A530&quot;, &quot;G300&quot;, &quot;N352&quot;, &quot;O000&quot;, &quot;C234&quot;]</span>

sound_ex.compare(<span class="s">&quot;phonetix&quot;</span>, <span class="s">&quot;phonetics&quot;</span>)
<span class="c"># =&gt; true</span>

metaphone.process(<span class="s">&quot;phonetics&quot;</span>)
<span class="c"># =&gt; &quot;FNTKS&quot;</span>

metaphone.tokenize_and_phoneticize(<span class="s">&quot;Ruby aint got nothing on Crystal&quot;</span>)
<span class="c"># =&gt; [&quot;RB&quot;, &quot;ANT&quot;, &quot;KT&quot;, &quot;KRSTL&quot;]</span>

<span class="c"># Keep word stops</span>
metaphone.tokenize_and_phoneticize(<span class="s">&quot;Ruby aint got nothing on Crystal&quot;</span>, <span class="n">true</span>)
<span class="c"># =&gt; [&quot;RB&quot;, &quot;ANT&quot;, &quot;KT&quot;, &quot;N0NK&quot;, &quot;ON&quot;, &quot;KRSTL&quot;]</span>

metaphone.compare(<span class="s">&quot;phonetix&quot;</span>, <span class="s">&quot;phonetics&quot;</span>)
<span class="c"># =&gt; true</span></code></pre>

<p>Both classes can also be used with attached String methods. The default class for String methods is <code>Metaphone</code>. The attached methods are <code>phonetics</code>, <code>sounds_like</code>, and <code>tokenize_and_phoneticize</code>.</p>

<pre><code class="language-crystal"><span class="s">&quot;Crystal&quot;</span>.phonetics
<span class="c"># =&gt; &quot;KRSTL&quot;</span>

<span class="s">&quot;Crystal&quot;</span>.sounds_like(<span class="s">&quot;Krystal&quot;</span>)
<span class="c"># =&gt; true</span>

<span class="s">&quot;Crystal&quot;</span>.phonetics(<span class="n">nil</span>, <span class="t">Cadmium</span><span class="t">::</span><span class="t">SoundEx</span>)
<span class="c"># =&gt; &quot;C234&quot;</span>

<span class="c"># Using a max length</span>
<span class="s">&quot;Constitution&quot;</span>.phonetics(<span class="n">6</span>, <span class="t">Cadmium</span><span class="t">::</span><span class="t">SoundEx</span>)
<span class="c"># =&gt; &quot;C52333&quot;</span></code></pre>

<h3>Inflectors</h3>

<h4>Nouns</h4>

<p>Nouns can be inflected using the <code>NounInflector</code> which has also been attached to the <code>String</code> class.</p>

<pre><code class="language-crystal">inflector <span class="o">=</span> <span class="t">Cadmium</span>.noun_inflector.<span class="k">new</span>

inflector.pluralize(<span class="s">&quot;radius&quot;</span>)
<span class="c"># =&gt; radii</span>

inflector.singularize(<span class="s">&quot;radii&quot;</span>)
<span class="c"># =&gt; radius</span>

<span class="s">&quot;person&quot;</span>.pluralize
<span class="c"># =&gt; people</span>

<span class="s">&quot;people&quot;</span>.singularize
<span class="c"># =&gt; person</span></code></pre>

<h4>Present Tense Verbs</h4>

<p>Present tense verbs can be inflected with the <code>PresentVerbInflector</code>. This has also been attached to the string class.</p>

<pre><code class="language-crystal">inflector <span class="o">=</span> <span class="t">Cadmium</span>.present_verb_inflector.<span class="k">new</span>

inflector.singularize(<span class="s">&quot;become&quot;</span>)
<span class="c"># =&gt; became</span>

inflector.pluralize(<span class="s">&quot;became&quot;</span>)
<span class="c"># =&gt; become</span>

<span class="s">&quot;walk&quot;</span>.singularize(<span class="n">false</span>) <span class="c"># noun: false</span>
<span class="c"># =&gt; walks</span>

<span class="s">&quot;walks&quot;</span>.pluralize(<span class="n">false</span>)  <span class="c"># noun: false</span>
<span class="c"># =&gt; walk</span></code></pre>

<h4>Numbers</h4>

<p>Numbers can be inflected with the <code>CountInflector</code> which also adds a method <code>to_nth</code> to the <code>Int</code> class.</p>

<pre><code class="language-crystal"><span class="t">Cadmium</span>.count_inflector.nth(<span class="n">1</span>)
<span class="c"># =&gt; 1st</span>

<span class="t">Cadmium</span>.count_inflector.nth(<span class="n">111</span>)
<span class="c"># =&gt; 111th</span>

<span class="n">153</span>.to_nth
<span class="c"># =&gt; 153rd</span></code></pre>

<h3>N-Grams</h3>

<p>N-Grams can be obtained for Arrays of Strings, or with single Strings (which will first be tokenized).</p>

<h4>bigrams</h4>

<pre><code class="language-crystal">ngrams <span class="o">=</span> <span class="t">Cadmium</span>.ngrams.<span class="k">new</span>
ngrams.bigrams(<span class="s">&quot;these are some words&quot;</span>)
<span class="c"># =&gt; [[&quot;these&quot;, &quot;are&quot;], [&quot;are&quot;, &quot;some&quot;], [&quot;some&quot;, &quot;words&quot;]]</span></code></pre>

<h4>trigrams</h4>

<pre><code class="language-crystal">ngrams <span class="o">=</span> <span class="t">Cadmium</span>.ngrams.<span class="k">new</span>
ngrams.trigrams(<span class="s">&quot;these are some words&quot;</span>)
<span class="c"># =&gt; [[&quot;these&quot;, &quot;are&quot;, &quot;some&quot;], [&quot;are&quot;, &quot;some&quot;, &quot;words&quot;]]</span></code></pre>

<h4>arbitrary n-grams</h4>

<pre><code class="language-crystal">ngrams <span class="o">=</span> <span class="t">Cadmium</span>.ngrams.<span class="k">new</span>
ngrams.ngrams(<span class="s">&quot;some other words here for you&quot;</span>, <span class="n">4</span>)
<span class="c"># =&gt; [[&quot;some&quot;, &quot;other&quot;, &quot;words&quot;, &quot;here&quot;], [&quot;other&quot;, &quot;words&quot;, &quot;here&quot;, &quot;for&quot;], [&quot;words&quot;, &quot;here&quot;, &quot;for&quot;, &quot;you&quot;]]</span></code></pre>

<h4>padding</h4>

<p>n-grams can also be returned with left or right padding by passing a start and/or end symbol to the bigrams, trigrams or ngrams.</p>

<pre><code class="language-crystal">ngrams <span class="o">=</span> <span class="t">Cadmium</span>.ngrams.<span class="k">new</span>
ngrams.ngrams(<span class="s">&quot;these are some words&quot;</span>, <span class="n">4</span>, <span class="s">&quot;[start]&quot;</span>, <span class="s">&quot;[end]&quot;</span>)
<span class="c"># =&gt; [</span>
      [<span class="s">&quot;[start]&quot;</span>, <span class="s">&quot;[start]&quot;</span>, <span class="s">&quot;[start]&quot;</span>, <span class="s">&quot;these&quot;</span>],
      [<span class="s">&quot;[start]&quot;</span>, <span class="s">&quot;[start]&quot;</span>, <span class="s">&quot;these&quot;</span>, <span class="s">&quot;are&quot;</span>],
      [<span class="s">&quot;[start]&quot;</span>, <span class="s">&quot;these&quot;</span>, <span class="s">&quot;are&quot;</span>, <span class="s">&quot;some&quot;</span>],
      [<span class="s">&quot;these&quot;</span>, <span class="s">&quot;are&quot;</span>, <span class="s">&quot;some&quot;</span>, <span class="s">&quot;words&quot;</span>],
      [<span class="s">&quot;are&quot;</span>, <span class="s">&quot;some&quot;</span>, <span class="s">&quot;words&quot;</span>, <span class="s">&quot;[end]&quot;</span>],
      [<span class="s">&quot;some&quot;</span>, <span class="s">&quot;words&quot;</span>, <span class="s">&quot;[end]&quot;</span>, <span class="s">&quot;[end]&quot;</span>],
      [<span class="s">&quot;words&quot;</span>, <span class="s">&quot;[end]&quot;</span>, <span class="s">&quot;[end]&quot;</span>, <span class="s">&quot;[end]&quot;</span>]
    ]</code></pre>

<h3>Classifiers</h3>

<p>Cadmium comes with one classifier so far, a Classic Bayes classifier. It is a probabalistic classifier that, when trained with a data set, can classify words according to categories.</p>

<pre><code class="language-crystal">classifier <span class="o">=</span> <span class="t">Cadmium</span>.bayes_classifier.<span class="k">new</span>

classifier.train(<span class="s">&quot;crystal is an awesome programming language&quot;</span>, <span class="s">&quot;programming&quot;</span>)
classifier.train(<span class="s">&quot;ruby is nice, but not as fast as crystal&quot;</span>, <span class="s">&quot;programming&quot;</span>)

classifier.train(<span class="s">&quot;my wife and I went to the beach&quot;</span>, <span class="s">&quot;off-topic&quot;</span>)
classifier.train(<span class="s">&quot;my dog likes to go outside and play&quot;</span>, <span class="s">&quot;off-topic&quot;</span>)

classifier.categorize(<span class="s">&quot;Crystal is my favorite!&quot;</span>)
<span class="c"># =&gt; &quot;programming&quot;</span></code></pre>

<h3>tf-idf</h3>

<p><a href="http://en.wikipedia.org/wiki/Tf%E2%80%93idf" target="_blank">Term Frequency‚ÄìInverse Document Frequency (tf-idf)</a> is implemented to determine how important a word (or words) is to a document relative to a corpus. The following example will add four documents to a corpus and determine the weight of the word "crystal" and then the weight of the word "ruby" in each document.</p>

<pre><code class="language-crystal">tfidf <span class="o">=</span> <span class="t">Cadmium</span>.tf_idf.<span class="k">new</span>
tfidf.add_document(<span class="s">&quot;this document is about crystal.&quot;</span>)
tfidf.add_document(<span class="s">&quot;this document is about ruby.&quot;</span>)
tfidf.add_document(<span class="s">&quot;this document is about ruby and crystal.&quot;</span>)
tfidf.add_document(<span class="s">&quot;this document is about crystal. it has crystal examples&quot;</span>)

puts <span class="s">&quot;crystal --------------------------------&quot;</span>
tfidf.tfidfs(<span class="s">&quot;crystal&quot;</span>) <span class="k">do</span> <span class="o">|</span>i, measure, key<span class="o">|</span>
  puts <span class="s">&quot;document #</span><span class="i">#{</span>i<span class="i">}</span><span class="s"> is </span><span class="i">#{</span>measure<span class="i">}</span><span class="s">&quot;</span>
<span class="k">end</span>

puts <span class="s">&quot;ruby --------------------------------&quot;</span>
tfidf.tfidfs(<span class="s">&quot;ruby&quot;</span>) <span class="k">do</span> <span class="o">|</span>i, measure, key<span class="o">|</span>
  puts <span class="s">&quot;document #</span><span class="i">#{</span>i<span class="i">}</span><span class="s"> is </span><span class="i">#{</span>measure<span class="i">}</span><span class="s">&quot;</span>
<span class="k">end</span>

<span class="c"># =&gt;  crystal --------------------------------</span>
      document <span class="c">#0 is 1</span>
      document <span class="c">#1 is 0</span>
      document <span class="c">#2 is 1</span>
      document <span class="c">#3 is 2</span>
      ruby </code></pre>

<h3>Transliterator</h3>

<p>The Transliterator module provides the ability to transliterate UTF-8 strings into pure ASCII so that they can be safely displayed in URL slugs or file names.</p>

<pre><code class="language-crystal">transliterator <span class="o">=</span> <span class="t">Cadmium</span>.transliterator

transliterator.transliterate(<span class="s">&quot;–ü—Ä–∏–≤–µ—Ç&quot;</span>)
<span class="c"># =&gt; &quot;Privet&quot;</span>

transliterator.transliterate(<span class="s">&quot;‰Ω†Â•ΩÊúãÂèã&quot;</span>)
<span class="c"># =&gt; &quot;Ni Hao Peng You&quot;</span>

<span class="c"># With the string extension</span>

<span class="s">&quot;ﬁâﬁ®ﬁáﬁ¶ﬁãﬁ¶ﬁÜﬁ© ﬁÄﬁã ﬁÉﬁ©ﬁåﬁ® ﬁãﬁàﬁÄﬁÜﬁà&quot;</span>.transliterate
<span class="c"># =&gt; &quot;mi&#39;adhakee hdh reethi dhvhkv&quot;</span>

<span class="s">&quot;„Åì„Çì„Å´„Å°„ÅØ„ÄÅÂèã‰∫∫&quot;</span>.transliterate
<span class="c"># =&gt; konnichiwa, You Ren</span></code></pre>

<h3>Sentiment Analysis</h3>

<p>The Sentiment module uses the <a href="http://www2.imm.dtu.dk/pubdb/views/publication_details.php?id=6010" target="_blank">AFINN-165</a> wordlist and <a href="http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0144296" target="_blank">Emoji Sentiment Ranking</a> to provide sentiment analysis on arbitrary blocks of text.</p>

<pre><code class="language-crystal">sentiment <span class="o">=</span> <span class="t">Cadmium</span>.sentiment

<span class="s">&quot;Crystal is seriously the best programming language.&quot;</span>.sentiment
<span class="c"># or</span>
sentiment.analyze(<span class="s">&quot;Crystal is seriously the best programming language.&quot;</span>)
<span class="c"># =&gt;  {</span>
        score: <span class="n">3</span>,
        comparative: <span class="n">0</span>,
        tokens: [<span class="s">&quot;Crystal&quot;</span>, <span class="s">&quot;is&quot;</span>, <span class="s">&quot;seriously&quot;</span>, <span class="s">&quot;the&quot;</span>, <span class="s">&quot;best&quot;</span>, <span class="s">&quot;programming&quot;</span>, <span class="s">&quot;language&quot;</span>],
        words: [<span class="s">&quot;best&quot;</span>],
        positive: [<span class="s">&quot;best&quot;</span>],
        negative: <span class="o">[]</span>
      }

<span class="s">&quot;I really hate Python&quot;</span>.is_negative?
<span class="c"># =&gt; true</span>

<span class="s">&quot;I really üíó Crystal. It&#39;s my favorite.&quot;</span>.is_positive?
<span class="c"># =&gt; true</span></code></pre>

<h3>Tries</h3>

<p>A <a href="https://en.wikipedia.org/wiki/Trie" target="_blank">trie</a> is a data structure for efficiently storing and retrieving strings with identical prefixes, like "<strong>mee</strong>t" and "<strong>mee</strong>k".</p>

<pre><code class="language-crystal">trie <span class="o">=</span> <span class="t">Cadmium</span>.trie.<span class="k">new</span>

trie.add(<span class="s">&quot;meet&quot;</span>)
trie.size
<span class="c"># =&gt; 5</span>

trie.add(<span class="s">&quot;meek&quot;</span>)
trie.size
<span class="c"># =&gt; 6</span>

trie.contains?(<span class="s">&quot;meet&quot;</span>)
<span class="c"># =&gt; true</span>

trie.find_prefix(<span class="s">&quot;meeting&quot;</span>)
<span class="c"># =&gt; {&quot;meet&quot;, &quot;ing&quot;}</span>
trie.find_prefix(<span class="s">&quot;meet&quot;</span>)
<span class="c"># =&gt; {&quot;meet&quot;, &quot;&quot;}</span>
trie.find_prefix(<span class="s">&quot;me&quot;</span>)
<span class="c"># =&gt; {nil, &quot;me&quot;}</span>

trie.keys_with_prefix(<span class="s">&quot;me&quot;</span>)
<span class="c"># =&gt; [&quot;meet&quot;, &quot;meek&quot;]</span>

trie.add([<span class="s">&quot;m&quot;</span>, <span class="s">&quot;me&quot;</span>])
trie.matches_on_path(<span class="s">&quot;meeting&quot;</span>)
<span class="c"># =&gt; [&quot;m&quot;, &quot;me&quot;, &quot;meet&quot;]</span></code></pre>

<h3>Edge Weighted Digraph</h3>

<p>EdgeWeightedDigraph represents a digraph, you can add an edge, get the number vertexes, edges, get all edges and use toString to print the Digraph.</p>

<pre><code class="language-crystal">digraph <span class="o">=</span> <span class="t">Cadmium</span>.edge_weighted_digraph.<span class="k">new</span>

digraph.add(<span class="n">5</span>, <span class="n">4</span>, <span class="n">0.35</span>)
digraph.add(<span class="n">5</span>, <span class="n">1</span>, <span class="n">0.32</span>)
digraph.add(<span class="n">1</span>, <span class="n">3</span>, <span class="n">0.29</span>)
digraph.add(<span class="n">6</span>, <span class="n">2</span>, <span class="n">0.40</span>)
digraph.add(<span class="n">3</span>, <span class="n">6</span>, <span class="n">0.52</span>)
digraph.add(<span class="n">6</span>, <span class="n">4</span>, <span class="n">0.93</span>)

puts digraph.v <span class="c"># =&gt; 7</span>
puts digraph.e <span class="c"># =&gt; 6</span></code></pre>

<h3>Readability</h3>

<p>Analyze blocks of text and determine, using various algorithms, the readability of the text.</p>

<pre><code class="language-crystal">text <span class="o">=</span> <span class="s">&lt;&lt;-EOF
    After marriage, the next big event in the couples lives will be their honeymoon. It is a time when the newly weds can get away from relatives and friends to spend some significant time getting to know one another. This time alone together that the couple shares is called the honeymoon. A great gift idea for the married couple would be to give them a surprise tour package. Most women would like to go on a honeymoon.
    The week or two before the ceremonies would be the best time to schedule a tour because then the budget for this event could be considered. In winter there are more opportunities for the couple to get close to one another because of the cold weather. It is easier to snuggle when the weather is not favorable to outdoor activities. This would afford the couple ample time to know more about themselves during the honeymoon.
    Honeymoon plans should be discussed with the wife to ensure that the shock is pleasant and not a negative experience to her. It is also a good idea in this case, to ask her probing questions as to where she would like to go. Perhaps you could get a friend or family member to ask her what would be her favorite travel location. That would ensure that you know just what she is looking for.
    Make sure that the trip is exactly what she wants. Then on the wedding night tell her about the adventure so that the needed accommodations can be made.
EOF</span>

report <span class="o">=</span> <span class="t">Cadmium</span>.readability.<span class="k">new</span>(text)

puts report.flesch  <span class="c"># =&gt; 71.47176470588238</span>
puts report.fog     <span class="c"># =&gt; 10.721568627450981</span>
puts report.kincaid <span class="c"># =&gt; 7.513725490196077</span></code></pre>

<h3>WordNet</h3>

<blockquote>> WordNet¬Æ is a large lexical database of English. Nouns, verbs, adjectives and adverbs are grouped into sets of cognitive synonyms (synsets), each expressing a distinct concept. Synsets are interlinked by means of conceptual-semantic and lexical relations. - <a href="https://wordnet.princeton.edu/" target="_blank">https://wordnet.princeton.edu/</a></blockquote>

<p>This WordNet implimentation is based almost completely on <a href="https://github.com/doches" target="_blank">doches</a> ruby library <a href="https://github.com/doches/rwordnet" target="_blank">rwordnet</a> with some extras thrown in and, of course, backed by the speed and type safety of Crystal. This is experimental and the API may change, but WordNet brings the power of the English (and hopefully other languages in the future) dictionary to your programs.</p>

<p>Using it is easy with Cadmium's API.</p>

<pre><code class="language-crystal"><span class="c"># Lookup a single word with a specific part of speech</span>
lemma <span class="o">=</span> <span class="t">Cadmium</span>.wordnet.lookup(<span class="s">&quot;horse&quot;</span>, <span class="n">:n</span>)
puts lemma.word.capitalize <span class="o">+</span> <span class="s">&quot; - &quot;</span> <span class="o">+</span> lemma.pos
lemma.synsets.each_with_index <span class="k">do</span> <span class="o">|</span>synset, i<span class="o">|</span>
  puts <span class="s">&quot;</span><span class="i">#{</span>i <span class="o">+</span> <span class="n">1</span><span class="i">}</span><span class="s">. </span><span class="i">#{</span>synset.gloss<span class="i">}</span><span class="s">&quot;</span>
<span class="k">end</span>

<span class="c"># Lookup a single word accross all parts of speech</span>
lemmas <span class="o">=</span> <span class="t">Cadmium</span>.wordnet.lookup(<span class="s">&quot;horse&quot;</span>)
lemmas <span class="o">=</span> lemmas.map { <span class="o">|</span>l<span class="o">|</span> {word: l.word, pos: l.pos, synsets: l.synsets} }
lemmas.each <span class="k">do</span> <span class="o">|</span>l<span class="o">|</span>
  word <span class="o">=</span> l[<span class="n">:word</span>].capitalize
  pos <span class="o">=</span> l[<span class="n">:pos</span>]
  l[<span class="n">:synsets</span>].each <span class="k">do</span> <span class="o">|</span>s<span class="o">|</span>
    puts <span class="s">&quot;</span><span class="i">#{</span>word<span class="i">}</span><span class="s"> (</span><span class="i">#{</span>pos<span class="i">}</span><span class="s">) - </span><span class="i">#{</span>s.gloss<span class="i">}</span><span class="s">&quot;</span>
  <span class="k">end</span>
<span class="k">end</span>


<span class="c"># Lookup a definition by offset and part of speech</span>
synset <span class="o">=</span> <span class="t">Cadmium</span>.wordnet.get(<span class="n">4424418</span>, <span class="n">:n</span>)
puts <span class="s">&quot;---------------------------------------------&quot;</span>
puts synset.synset_offset
puts synset.pos
puts synset.gloss
puts synset.word_counts</code></pre>

<h2>Roadmap</h2>

<p>This is all I want to have done before a <strong>v1.0</strong> release.</p>

<ul><li>[x] Tokenizers</li><ul><li>[x] AggressiveTokenizer</li><li>[x] i18n</li><li>[x] CaseTokenizer</li><li>[x] Pragmatic <a href="https://github.com/diasks2/pragmatic_tokenizer" target="_blank">?</a></li><li>[x] RegexTokenizer</li><li>[x] SentenceTokenizer</li><li>[x] TreebankWordTokenizer</li><li>[x] WhitespaceTokenizer</li><li>[x] WordPunctuationTokenizer</li></ul><li>[x] String Distance</li><ul><li>[x] Levenshein</li><li>[ ] Approximate String Matching</li><li>[x] JaroWinkler</li></ul><li>[ ] Stemmers</li><ul><li>[x] PorterStemmer</li><li>[ ] i18n</li><li>[ ] LancasterStemmer</li><li>[ ] i18n</li></ul><li>[ ] Classifiers</li><ul><li>[x] Bayes</li><li>[ ] Logic Regression </li></ul><li>[x] Phonetics</li><ul><li>[x] SoundEx</li><li>[x] Metaphone</li><li>[ ] Double Metaphone</li></ul><li>[x] Inflectors</li><ul><li>[x] Count</li><li>[x] Noun</li><li>[x] Verb</li><li>[ ] i18n</li></ul><li>[x] N-Grams</li><li>[x] TF-IDF</li><li>[x] Transliterator</li><li>[x] Sentiment Analysis</li><li>[x] Tries</li><li>[x] EdgeWeightedDigraph</li><li>[x] Readability</li><li>[x] WordNet</li><li>[ ] ShortestPathTree</li><li>[ ] LongestPathTree</li><li>[ ] Spellcheck</li><li>[ ] POS Tagger</li><li>[ ] Word2Vec</li></ul>

<h2>Contributing</h2>

<ol><li>Fork it ( https://github.com/watzon/cadmium/fork )</li><li>Create your feature branch (git checkout -b my-new-feature)</li><li>Commit your changes (git commit -am 'Add some feature')</li><li>Push to the branch (git push origin my-new-feature)</li><li>Create a new Pull Request</li></ol>

<h2>Contributors</h2>

<ul><li><a href="https://github.com/watzon" target="_blank">watzon</a> Chris Watson - creator, maintainer</li></ul>
</div>
</body>
</html>
